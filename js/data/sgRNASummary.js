
class SgRNASummary {
  /**
   * Create a SgRNASummary object to handle data from *.count.txt and *.sgrna_summary.txt files
   */
  constructor() {}

  /**
   * True if both the summary and counts are loaded
   */
  get ready() {
    return this.data.length > 0 && this.counts;
  }
  /**
   * True if there is at least one library loaded
   */
  get hasLibrary() {
    return this.sgLibrary.length > 0;
  }

  data = [];
  sgLibrary = [];
  counts = false;
  header = [];

  /**
   * Parse a library file
   * @param {*} file file value of an input element (let file = el.files[0])
   * @param {*} libName name of the library
   * @returns Promise<number> return the index of the added library
   */
  parseLibrary(file, libraryName) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      let data = "";
      reader.onload = () => {
        data = data + reader.result;
      };
      reader.readAsText(file);
      reader.onloadend = () => {
        let lib = { name: libraryName, sgrnas: [] };
        data = data.split("\n");
        let line;
        for (let idx = 0; idx < data.length; idx++) {
          line = data[idx].split("\t");
          lib.sgrnas.push(line[0]);
        }
        this.sgLibrary.push(lib);
        resolve(this.sgLibrary.length - 1);
      };
    });
  }
  /**
   * Parse and import a *.sgrna_summary.txt file
   * @param {string} data The text content of a *.sgrna_summary.txt file
   * @returns Promise<void>
   */
  parseSgCount(data) {
    return new Promise((resolve, reject) => {
      this.counts = {};
      data = data.split("\n");
      let line;
      for (let idx = 0; idx < data.length; idx++) {
        line = data[idx].split("\t");
        if (idx == 0) {
          if (line[0] != "sgRNA" || line[1] != "Gene") {
            reject("The input file is not a sgRNA count generated by MAGeCK.");
            return;
          } else {
            this.samples = line.slice(2).map((v, idx) => {
              return { name: v, order: idx, group: undefined };
            });
          }
        } else {
          this.counts[line[0]] = line.slice(2).map((v) => parseFloat(v));
        }
      }
      resolve();
      return;
    });
  }
  /**
   * Prepare the dataset by merging the information of the count and the summary files
   * @returns Promise<void>
   */
  mergeCountSummary() {
    return new Promise((resolve, reject) => {
      if (this.hasLibrary) {
        this.data.forEach((sg) => {
          sg.counts = this.counts[sg.sgrna];
          sg.library = this.sgLibrary.find((sgl) =>
            sgl.sgrnas.includes(sg.sgrna)
          )?.name;
        });
      } else {
        /// Calabrese Libraries: setA are just number, setB are geneName_number
        this.data.forEach((sg) => {
          sg.counts = this.counts[sg.sgrna];
          sg.library = sg.sgrna.match(/^[0-9]+$/) ? "libA" : "libB";
        });
      }
      this.counts = true;
      this.normalization_factors = this.computeNormalizationFactors(this.data);
      resolve();
    });
  }
  /**
   * Compute the normalization factors over the control as done in MAGeCK
   * @param {{gene : string, counts :number[]}[]} data The data from which the normalization factors are computed
   * @returns number[]
   */
  _computeControlNormFactor(data) {
    let d1 = data.filter((sg) => sg.gene == this.control_gene);
    if (d1.length == 0) {
      return Array(data[0].counts.length).fill(1);
    } else {
      return this._computeMedianNormFactor(d1);
    }
  }

  /**
   * Compute the normalization factors over the median as done in MAGeCK
   * @param {{gene : string, counts :number[]}[]} data The data from which the normalization factors are computed
   * @returns number[]
   */
  _computeMedianNormFactor(data) {
    let n = data[0].counts.length;
    let m = data.length;
    let meanVal = Array(m).fill(-1);
    data.forEach((cnt, idx) => {
      if (cnt.counts.reduce((p, v) => p + v, 0) > 0) {
        meanVal[idx] = Math.exp(
          (cnt.counts.map((v) => Math.log(v + 1)).reduce((p, c) => p + c, 0) *
            1.0) /
            n
        );
        if (meanVal[idx] <= 0) {
          meanVal[idx] = 1;
        }
      }
    });
    let medianFactor = Array(n).fill(0);
    for (let ni = 0; ni < n; ni++) {
      let meanFactor = data
        .map((sg, idx) => sg.counts[ni] / meanVal[idx])
        .filter((v, idx) => meanVal[idx] != -1);
      let xFactor = meanFactor.sort()[Math.floor(meanFactor.length / 2)];
      medianFactor[ni] = xFactor > 0 ? 1.0 / xFactor : 0;
    }
    return medianFactor;
  }

  /**
   * Compute the normalization factors over the total counts as done in MAGeCK
   * @param {{gene : string, counts :number[]}[]} data The data from which the normalization factors are computed
   * @returns number[]
   */
  _computeTotalNormFactor(data) {
    let n = data[0].counts.length;
    let m = data.length;
    let sumSamples = Array(n).fill(0);
    data.forEach((cnt) => {
      cnt.counts.forEach((v, i) => (sumSamples[i] += v));
    });
    let avgSample = sumSamples.reduce((p, c) => p + c, 0) / n;
    return sumSamples.map((v) => avgSample / v);
  }
  /**
   * Compute all the normalization factors as done in MAGeCK
   * @param {{gene : string, counts :number[]}[]} data The data from which the normalization factors are computed
   * @returns {raw : number[],total : number[], median : number[], control : number[]}
   */
  computeNormalizationFactors(data) {
    /// Adapted from mageckCountNorm.py
    let normalization_factors = {};
    normalization_factors.raw = Array(data[0].counts.length).fill(1);
    normalization_factors.total = this._computeTotalNormFactor(data);
    normalization_factors.median = this._computeMedianNormFactor(data);
    normalization_factors.control = this._computeControlNormFactor(data);
    return normalization_factors;
  }

  /**
   * Parse and import a *sgrna_summary.txt file
   * @param {string} data the content of a sgrna summary file
   * @returns Promise<void>
   */
  parse(data) {
    return new Promise((resolve, reject) => {
      this.data = [];
      data = data.split("\n");
      let line;
      for (let idx = 0; idx < data.length; idx++) {
        line = data[idx].split("\t");
        if (idx == 0) {
          if (line[0] != "sgrna" || line[1] != "Gene" || line.length != 15) {
            reject(
              "The input file is not a single guide RNA Summary generated by MAGeCK."
            );
            return;
          } else {
            this.header = line;
          }
        } else {
          if (line.length == 15) {
            this.data.push({
              sgrna: line[0],
              gene: line[1],
              means: line.slice(4, 6).map((v) => parseFloat(v)),
              LFC: parseFloat(line[6]),
              control_var: parseFloat(line[7]),
              adj_var: parseFloat(line[8]),
              score: parseFloat(line[9]),
              pLow: parseFloat(line[10]),
              pHigh: parseFloat(line[11]),
              pvalue: parseFloat(line[12]),
              FDR: parseFloat(line[13]),
              highInTreatment: line[14] == "True",
            });
          }
        }
      }
      resolve()
      return;
    });
  }
}

export {SgRNASummary}
