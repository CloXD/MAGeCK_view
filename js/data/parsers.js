function parseGeneSummaryData(data) {
  return new Promise((resolve, reject) => {
    let out = { data: [], header: [] };
    data = data.split("\n");
    let line;
    for (let idx = 0; idx < data.length; idx++) {
      line = data[idx].split("\t");
      if (idx == 0) {
        if (line[0] != "id" || line[1] != "num" || line.length != 14) {
          reject("The input file is not a gene Summary generated by MAGeCK.");
          return;
        } else {
          out.header = line;
        }
      } else {
        if (line.length == 14) {
          let d = {
            gene: line[0],
            numSgRNA: parseInt(line[1]),
            neg: {
              score: parseFloat(line[2]),
              pvalue: parseFloat(line[3]),
              FDR: parseFloat(line[4]),
              rank: parseFloat(line[5]),
              good: parseInt(line[6]),
              LFC: parseFloat(line[7]),
            },
            pos: {
              score: parseFloat(line[8]),
              pvalue: parseFloat(line[9]),
              FDR: parseFloat(line[10]),
              rank: parseFloat(line[11]),
              good: parseInt(line[12]),
              LFC: parseFloat(line[13]),
            },
            best: "pos",
            rank: 0,
          };
          if (d.neg.pvalue == d.pos.pvalue) {
            if (Math.abs(d.neg.LFC) > d.pos.LFC) {
              d.best = "neg";
            }
          } else {
            if (d.neg.pvalue < d.pos.pvalue) {
              d.best = "neg";
            }
          }
          d.LFC = d[d.best].LFC;
          d.pvalue = d[d.best].pvalue;
          d.FDR = d[d.best].FDR;
          out.data.push(d);
        }
      }
    }
    let ranking = [...Array(out.data.length).keys()];
    ranking = ranking.sort((a, b) => {
      return out.data[a].LFC > out.data[b].LFC ? -1 : 1;
    });
    ranking.forEach((idx, r) => {
      out.data[idx].rank = r;
    });
    resolve(out);
  });
}

/**
   * Parse and import a *.sgrna_summary.txt file
   * @param {string} data The text content of a *.sgrna_summary.txt file
   * @returns Promise<void>
   */
function parseSgCountData(data) {
  return new Promise((resolve, reject) => {
    let out = { counts : {}, samples : [] };
    data = data.split("\n");
    let line;
    for (let idx = 0; idx < data.length; idx++) {
      line = data[idx].split("\t");
      if (idx == 0) {
        if (line[0] != "sgRNA" || line[1] != "Gene") {
          reject("The input file is not a sgRNA count generated by MAGeCK.");
          return;
        } else {
          out.samples = line.slice(2).map((v, idx) => {
            return { name: v.replace("\.", "_"), order: idx };
          });
        }
      } else {
        out.counts[line[0]] = line.slice(2).map((v) => parseFloat(v));
      }
    }
    resolve(out);
    return;
  });
}

/**
   * Parse and import a *sgrna_summary.txt file
   * @param {string} data the content of a sgrna summary file
   * @returns Promise<void>
   */
function parseSgRNASummaryData(data) {
  return new Promise((resolve, reject) => {
    let out = { data : [] , header : []};
    data = data.split("\n");
    let line;
    for (let idx = 0; idx < data.length; idx++) {
      line = data[idx].split("\t");
      if (idx == 0) {
        if (line[0] != "sgrna" || line[1] != "Gene" || line.length != 15) {
          reject(
            "The input file is not a single guide RNA Summary generated by MAGeCK."
          );
          return;
        } else {
          out.header = line;
        }
      } else {
        if (line.length == 15) {
          out.data.push({
            sgrna: line[0],
            gene: line[1],
            control_count : line[2],
            treatment_count : line[3],
            means: line.slice(4, 6).map((v) => parseFloat(v)),
            LFC: parseFloat(line[6]),
            control_var: parseFloat(line[7]),
            adj_var: parseFloat(line[8]),
            score: parseFloat(line[9]),
            pLow: parseFloat(line[10]),
            pHigh: parseFloat(line[11]),
            pvalue: parseFloat(line[12]),
            FDR: parseFloat(line[13]),
            highInTreatment: line[14] == "True",
          });
        }
      }
    }
    resolve(out)
  });
}

export {parseGeneSummaryData, parseSgCountData, parseSgRNASummaryData}